1、复杂选择器（重点）
	1、兄弟选择器：通过元素的平级关系来匹配其他元素
		1、分类
			1、相邻兄弟选择器：匹配指定元素的相邻（挨在后面）兄弟（只能匹配后面的相邻兄弟）
				语法：选择器1+选择器2{}
			2、通用兄弟选择器：匹配指定元素后面所有的兄弟元素
				语法：选择器1~选择器2
	2、属性选择器：允许使用元素所附带的属性及其值来匹配页面的全部元素(唯一一组以中括号（[]）来进行表示的选择器)
		语法：
			1、[attr]{}
				attr:任意属性名称
				匹配 附带 attr 属性的元素
					ex:
						[id]
						匹配页面中全部有id的元素
			2、elem[attr]{}
				匹配附带 attr 属性的 elem 元素
			3、elem[attr1][attr2]{}
				匹配页面中所有既 附带attr1元素也同时 附带attr2属性的elem元素
			4、elem[attr="value"]{}
				匹配页面上 附带attr属性同时值为 value 的elem 元素
			5、elem[class~="value"]{}
				匹配 附带class 属性的 elem元素,其中 class属性  的值是以空格隔开的值列表, value 是值列表中的一个独立值（也就是空格后面的值）
					ex: class="value1 value2"
			6、elem[attr^="value"]{}
				匹配 附带attr 属性的 elem 元素，并且该属性值是以 value 作为开始
			7、elem[attr$="value"]
				匹配 附带attr 属性的 elem 元素，并且该属性值是以 value 作为结束
			8、elem[attr*="value"]
				匹配 附带attr 属性的 elem 元素，并且该属性值中包含 value
	3、伪类选择器
		1、目标伪类：突出显示活动的HTML锚元素
			匹配当前页面中活动的HTML锚元素
			:target{}
		2、元素状态伪类0
			元素状态:启用，禁用，被选中
			:enabled,匹配每个已启用元素（主要用在表单控件上）
			:disabled,匹配每个已禁用元素（表单控件）
			:checked,匹配每个被选中元素(radio,checked)
		3、结构伪类（重点）
			1、:first-child{}
				匹配属于其父元素中的首个子元素
			2、:last-child{}
				匹配属于其父元素中的最后一个子元素
			3、:nth-child(number){}
				匹配属于其父元素中的第number个子元素
			4、:empty{}
				匹配 没有子元素（包括文本）的每个元素
			5、:only-child{}
				匹配 属于其父元素中的唯一子元素
		4.否定伪类
			:not(选择器){}
				将满足选择器的元素从指定范围中排除出去
	4、伪元素选择器
		伪类：匹配元素
		伪元素：匹配元素中的内容
			1、:first-letter{}/::first-letter{}
				匹配 指定元素的 首字符
			2、:first-line{}/::first-line{}
				匹配 指定元素的 首行
			3、::selection{
				color:
				background:
				}
				匹配 被用户选取的部分
		:和::的区别
			CSS3之前，所有的伪元素选择器，全部都用:
			CSS3中，将所有伪元素选择器全部都升级为::
			为了能够实现浏览器的兼容性，比较推荐使用:的写法
2、内容生成：通过 CSS 向现有的 元素内容区域中增加一部分内容
	1、伪元素选择器
		1、:before/::before
			匹配到某元素的内容区域之前
				<div>(内容区域之前)Hello World</div>
		2、:after/::after
			匹配到某元素的内容区域之后
				<div>Hello World(内容区域之后)</div>
		3、	属性：content:
			取值：
				1、字符串:纯文本
				2、url:图像
				3、计数器
	***********
	2、:before/:after的应用：
		1、解决上(下)外边距溢出问题
			div:before/div:after{
				content:"";
				display:table;
			}
		2、0影响清除浮动以及解决父元素的宽/高问题
			div:after{
				content:"";
				display:block;
				clear:both;
			}
	***********
	3、计数器:生成一段有序的数字，并插入元素
		1、声明（复位）计数器 
			属性：counter-reset:
			取值：
				1、0;（默认值）
				2、可以取值为 正数或负数
			counter-reset:计数器名称 值;
			一次性声明多个计数器
			counter-reset:名1 值 名2 值;
	*********************************************
		在什么地方声明计数器：
			不可以放在使用的元素中声明
			1、元素全部都用计数器 放在body
			2、某元素要用 放在其 父元素中
	*******************************************
		2、设置计数器的增量：设置某个选择器出现的计数器的增量，默认值为1
			属性:counter-increment:
			counter-increment:名称 增量值;
			
			在什么地方声明计数器增量：
			哪个元素使用，就在哪个元素中设置增量
		3、使用计数器
			1、函数
				counter(计数器名称)
				配合着 :before 和 :after 一起使用
				计数元素:beofre{content:counter(计数器名);}
3、多列
	1、分隔列：将一段文本拆分成几列
		column-count:数字;
	2、列间隔：两列之间的间隔距离
		column-gap:**px;
	3、列规则:两列之间增加分割线
		column-rule:wdith style color;
4、CSS Hack（解决浏览器兼容性）
	1、解决问题
		IE各版本浏览器兼容性问题
	2、CSS Hack
		浏览器的类型及版本不同会造成CSS的解析效果也各不相同
			不同厂商浏览器
			：IE,Chrome,Firefox,Safari
			同一厂商浏览器的不同版本
			：IE6,IE7,IE8,IE9,IE10
	3、CSS Hack原理
		使用 CSS样式属性的 优先级 来解决兼容性问题
	4、CSS Hack 分类
		1、CSS类内部Hack
			通过 属性前缀或值后缀 的方式来解决兼容性

			+:被IE6，IE7识别 
			-:被IE6识别
			+、-同时出现:-只识别IE6，+只识别IE7，并且顺序一定是要先设置 + 后设置 -
				IE浏览器兼容性顺序：
					/0		:IE8/9/10
					/9/0	:IE9/10
					+		:IE6/7
					-		:IE6
		2、选择器Hack
			在选择器前加上某些浏览器能识别的前缀
				*body{}：IE6
				*+body{}:IE7
		3、HTML头部引用Hack（最实用）
			1、原理
				通过IE条件注释 解决兼容性问题
				IE浏览器会根据一个if条件判断，来判断指定的内容是要被解析还是注释
	***********************************************************
			2、语法
				<!--[if 条件 IE 版本]>
					<link rel="stylesheet" href="style_ie版本.css" />
				<![endif]-->
				版本：6~10 数字
				条件：
					1、gt:大于指定版本的浏览器
					2、gte:大于等于指定版本的浏览器
					3、lt:小于指定版本的浏览器
					4、lte:小于等于指定版本的浏览器
					5、!:除条件版本以外的其他版本浏览器
	**********************************************************