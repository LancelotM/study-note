1、作用域和作用域链
	1、作用域(scope)：一个变量的使用范围————使用角度
					本质上是一个对象————存储
					作用域中的变量都是对象的成员
		原理：
			程序/函数的执行过程:
				1、开始执行程序前
					创建ECS(执行环境栈):依次保存每个调用的函数的执行环境
					在ECS中压入第一个全局执行环境(全局EC/全局环境)
					创建window对象，全局EC引用window对象
				2、开始执行程序
					所有全局变量，都保存在全局作用域对象window中
				3、定义函数时
					在全局添加函数名变量
					创建函数对象，来封装函数的定义
					函数名变量引用函数对象
					函数对象中有一个scope属性，引用回创建函数时的作用域对象。通常都是window
				4、调用函数时
					在ECS中压入一个新的EC
					为本次函数调用创建专门的活动对象(AO)
					在AO中创建所有函数定义中包含的局部变量
					其实AO就是函数作用域对象
						所有局部变量都是AO的成员
					新的EC引用活动对象AO
					AO的parent指向window
					变量的使用顺序：先用AO(函数作用域)中的局部变量
									如果AO中没有，才去window(全局作用域)中找
				5、函数调用后
					本次函数调用的EC出栈
						导致函数作用域AO释放
							导致局部变量一同释放
	2、作用域链：由多个作用域对象连续引用形成的链式结构
		顺序：现函数作用域对象AO->全局作用域对象window
		所有的变量都保存在作用域链上的对象中
			局部变量都保存在函数作用域对象AO中
			全局变量都保存在全局作用域对象window中
		控制了：变量的使用顺序


2、闭包(closure)：既重用变量，又防止变量被污染的一种机制
	为什么：
		全局变量：	优点：可重用		缺点：易内全局污染
		局部变量：	优点：不会被污染	缺点：不可重用
	场合：既想重用变量，又想防止变量被污染
	如何：3步
		1、用外层函数包裹住受保护的变量和操作变量的内层函数
		2、外层函数将内层函数返回到外部，被外部的变量接住并保存(3种)
			1、return function(){}
			2、直接给全局变量赋值
			3、将函数保存在一个对象的属性或数组元素中
				1、return arr[function fun(){}]
				2、return {function fun(){}}
		3、通过外部变量调用内层函数，访问受保护的变量，赋值给全局变量
	缺点：
		1、占用更多的内容：外内函数的AO
		2、容易造成内容泄露
	特点：
		1、函数嵌套
		2、外层函数包含一个受保护的局部变量
		3、外层函数将内层函数对象返回
	笔试题：
		快速绘制闭包图
			1、受保护的变量，并确定外层函数调用后，变量的值
			2、找所有操作受保护变量的内层函数
		闭包如何形成
			外层函数调用后，外层函数的作用域对象(AO)，无法释放
		如何释放闭包
			将引用内存函数对象的变量为null
	

3、面向对象(OOP):程序中都是先用对象来定义数据和功能，再按照逻辑的需要，访问对象中的数据和功能
	为什么：和现实中人的想法非常接近
	什么是对象：内存中同时存储多个数据和功能的存储空间
		描述现实中一个具体事物的属性和功能的程序结构
			事物的属性，会成为对象中的属性
			事物的功能，会成为对象中的方法
	场合：今后开始写程序前，都要先用对象，描述好要操作的事物的属性和功能，再按需使用对象的功能，访问对象的属性
	如何：
		1、创建自定义对象————封装 3种
			1、使用对象直接量：{}
				var obj={
					属性名:属性值,
					...:...,
					方法名:function(){...},
					...:...,
				}

		强调：如果对象自己的方法，要访问自己的属性，必须用this.属性名
				this->正在调用函数的当前对象自己
				如果不加this，仅会在作用域链中找

			2、使用new:2步
				//创建一个空对象
				var obj=new Object()/{};
				(new可省略,()可省略,但不能同时省略)
				//向空对象中添加属性和方法
				obj.属性名=属性值;
				obj.方法名=function(){..this.属性名..};
		
		对象的本质：JS中一切对象的底层都是关联数组
					每个属性/方法
	*************************************************

			3、构造函数:专门描述一类对象统一结构的函数
				何时“今后只要反复创建多个结构相同的对象
				为什么:复用对象的结构代码
				如何:2步
					1、定义构造函数
						function 类型名(属性参数列表){
							this.属性名=属性参数值;
							...=...;
							/*this.方法名=function(){
								this.属性名*/
							}
							//JS不建议把方法放在构造函数中,可以放在prototype(原型对象)中
						}
					2、调用构造函数创建新对象
						var obj=new 类型名(属性名列表);
						new:4事
							1、创建一个空对象
							2、让新对象继承构造函数的原型对象
							3、用新对象去调用构造函数
								向新对象中添加构造函数规定的属性
								将属性参数的值，保存到新对象的新属性中
								向新对象中添加构造函数规定的方法
							4、将新对象的地址保存在变量中
				问题：只能代码重用，不能节约内存

		2、按需访问对象的属性，调用对象的方法
			访问对象的属性：obj.属性名	用法和普通的变量完全一样
				属性就是保存在对象中的一个变量
			调用对象的方法：obj.方法名() 用法和普通的函数完全一样
4、面向对象三大特点：封装、继承、多态
	封装：将一个具体事物的属性和功能集中定义在一个对象中
	继承：父对象的成员，子对象不用重复创建，也可直接使用
		为什么(偷懒):既节约空间，又代码重用
		场合：只要一类子对象，需要相同的属性或功能时，都要将相同的属性和功能仅在父对象中定义一次即可
		如何：
			原型对象(prototype)：集中存储同一类型的子对象所需的所有共有属性和方法的父对象