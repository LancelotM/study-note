<!doctype html>
<html>
<head>
	<meta charset="UTF-8">
	<title>标题</title>
</head>
<body>
	<script type="text/javascript">
		function row(){
			var input=prompt("请输入任意一个数，将会打印出该行的乘法口诀表")
			var result="";
			for(i=1;i<=input;i++){
				result+=(i+"*"+input+"="+(i*input)+"\t");
			}
			console.log(result);
		}

		function sum_fs(){
			var sum=0;
			for(i=1;i<=1000;i+=2){
				sum+=1/i;
			}
			console.log(sum);
		}

		function ss(){
			var input=Number(prompt("请输入任意一个数，将会判断是不是素数"))
			var isSu=true;
			for(i=2;i<input-1;i++){
				if(input%i==0){
					isSu=false;
					break;
				}
			}
			if(isSu==true){
				console.log("是素数");
			}else{
				console.log("不是素数");
			}
		}

		function tuZi(){
			var n1=1,n2=1;
			console.log(n1+","+n2)
			for(i=1;i<10;i++){
				n1=n1+n2;
				n2=n1+n2;
				console.log(n1+","+n2);
			}
		}

		/*递归函数:在函数内，又调用了自己，递归调用的内层函数，是在外层函数还结束时就已经开始了，外层函数的调用，就会被阻塞
		缺点：算法复杂度太高，而且浪费内存
		解决：绝大部分递归，可以使用循环替代
		*/


		function f_dg(n){
			if(n==2||n==1){
				return 1;
			}
			return f_dg(n-1)+f_dg(n-2);			
		}



		function f_fdg(n){
			if(n==2||n==1){
				return 1;
			}else{
				var f1=1,f2=1,fn;
				for(i=1;i<=n-2;i++){
					fn=f1+f2;
					f1=f2;
					f2=fn;
				}
				return fn;
			}
		}
	</script>	
	<button onclick="row();">点我输入任意一个数，将会打印出该行的乘法口诀表</button>
	<button onclick="sum_fs();">分数和</button>
	<button onclick="ss();">判断一个数是不是素数</button>
	<button onclick="tuZi();">兔子</button>
	<button onclick="console.log(f_dg(5));">递归</button>
	<button onclick="console.log(f_fdg(5));">非递归</button>


</body>
</html>